<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Agar.io - Bots</title>
  <style>
    :root{--bg:#071021; --muted:rgba(255,255,255,0.9); --accent:#19f0ff}
    html,body{height:100%;margin:0}
    body{background:linear-gradient(180deg,#071021,#0f1a2b);color:var(--muted);font-family:Inter,Segoe UI,Roboto,Arial}
    #game{display:block;width:100vw;height:100vh}
    .ui{position:fixed;left:16px;top:16px;z-index:20;background:rgba(0,0,0,0.25);padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,0.04)}
    .ui button{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted);padding:6px 10px;border-radius:8px;cursor:pointer}
    .overlay{position:fixed;right:16px;top:16px;background:rgba(0,0,0,0.25);padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,0.04)}
    .center-msg{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.45);padding:18px;border-radius:12px;border:1px solid rgba(255,255,255,0.06);display:none}
    .center-msg.show{display:block}
  </style>
</head>
<body>
  <canvas id="game"></canvas>

  <div class="ui">
    <button id="back">← Retour</button>
    <button id="reset">Recommencer</button>
  </div>

  <div class="overlay" id="hud">
    <div id="mass">Mass: 0</div>
    <div id="bots">Bots: 0</div>
    <div id="food">Food: 0</div>
  </div>

  <div class="overlay" id="leaderboard" style="right:16px;top:120px;">
    <div style="font-weight:600;margin-bottom:6px">Leaderboard</div>
    <div id="leaders">Loading...</div>
  </div>

  <div class="center-msg" id="msg">
    <div id="msgText">Game Over</div>
    <div style="margin-top:10px;text-align:center"><button id="playAgain">Jouer encore</button></div>
  </div>

  <script>
    // Minimal agar-like game with improved bots + split mechanic
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let DPR = Math.max(1, window.devicePixelRatio || 1);

    function resize(){
      DPR = Math.max(1, window.devicePixelRatio || 1);
      canvas.width = Math.floor(window.innerWidth * DPR);
      canvas.height = Math.floor(window.innerHeight * DPR);
      canvas.style.width = window.innerWidth + 'px';
      canvas.style.height = window.innerHeight + 'px';
      ctx.setTransform(DPR,0,0,DPR,0,0);
    }
    window.addEventListener('resize', resize);
    resize();

    // Game state
    const WIDTH = () => canvas.width / DPR;
    const HEIGHT = () => canvas.height / DPR;

    // Utility
    function rand(min, max){ return Math.random()*(max-min)+min }
    function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy) }
    function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

    // Player: main piece + shards
    const mainPlayer = { x: WIDTH()/2, y: HEIGHT()/2, mass: 120, color:'#ffffff', vx:0, vy:0 };
    const shards = []; // split pieces

    function massToRadius(m){ return Math.max(6, Math.sqrt(m/Math.PI)*2.6) }

    // bot speed scaling: larger bots should move slower (clamped)
    function botSpeedFactor(mass){
      // reduces speed as mass grows; clamp so very large bots still move a little
      return Math.max(0.25, 1 - Math.log(mass + 1) * 0.06);
    }

    // Bots
  const BOT_COUNT = 140; // tune for perf
  const bots = [];
  // declare food constants early so placement helper can reference the array
  const FOOD_COUNT = 120;
  const foods = [];

    // find a position that is not too close to other entities (bots, foods, player, shards)
    function findSafePosition(radius, maxAttempts = 40){
      const margin = Math.max(12, radius + 6);
      for(let attempt = 0; attempt < maxAttempts; attempt++){
        const x = rand(margin, WIDTH() - margin);
        const y = rand(margin, HEIGHT() - margin);
        let ok = true;
        // check against player
        if(dist({x,y}, mainPlayer) < (massToRadius(mainPlayer.mass) + radius + 6)) ok = false;
        // check against shards
        if(ok){
          for(const s of shards){ if(dist({x,y}, s) < (massToRadius(s.mass) + radius + 6)){ ok = false; break; } }
        }
        // check against existing bots
        if(ok){
          for(const b of bots){ if(dist({x,y}, b) < (massToRadius(b.mass) + radius + 6)){ ok = false; break; } }
        }
        // check against foods
        if(ok){
          for(const f of foods){ const fr = Math.max(2, Math.sqrt(f.mass/Math.PI)*1.6); if(dist({x,y}, f) < (fr + radius + 4)){ ok = false; break; } }
        }
        if(ok) return {x,y};
      }
      // fallback: return a random position (can't find safe spot)
      return { x: rand(20, WIDTH()-20), y: rand(20, HEIGHT()-20) };
    }

    function spawnBot(){
      const m = rand(8, 160);
      const r = massToRadius(m);
      const p = findSafePosition(r);
      return {
        x: p.x,
        y: p.y,
        mass: m,
        color: `hsl(${Math.floor(rand(0,360))}deg 80% 60%)`,
        dir: rand(0,Math.PI*2),
        speed: rand(0.18,0.9),
        // simple memory
        target: null
      };
    }

    // initialize bots (after spawnBot and findSafePosition are available)
    for(let i=0;i<BOT_COUNT;i++) bots.push(spawnBot());

    // Food pellets
    function spawnFood(){
      const m = Math.round(rand(2, 10));
      // approximate radius used in drawList for foods
      const r = Math.max(2, Math.sqrt(m/Math.PI)*1.6);
      const p = findSafePosition(r);
      return {
        x: p.x,
        y: p.y,
        mass: m,
        color: `hsl(${Math.floor(rand(80,140))}deg 60% ${Math.floor(rand(45,65))}%)`
      };
    }
    // initialize foods (moved population after spawn helpers so safe-placement works)
    for(let i=0;i<FOOD_COUNT;i++) foods.push(spawnFood());

    // Input
    const mouse = { x: mainPlayer.x, y: mainPlayer.y };
    window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY });
    window.addEventListener('touchmove', e => { if(e.touches[0]){ mouse.x = e.touches[0].clientX; mouse.y = e.touches[0].clientY } }, {passive:true});

  // HUD elements
  const massEl = document.getElementById('mass');
  const botsEl = document.getElementById('bots');
  const foodEl = document.getElementById('food');
  const leadersEl = document.getElementById('leaders');

    let running = true;

    // Split mechanic
    const SPLIT_MIN_MASS = 60; // minimum mass to allow split
    const SHARD_LIFETIME = 2200; // ms before shard can merge
    function trySplit(){
      if(mainPlayer.mass <= SPLIT_MIN_MASS) return;
      // shard mass taken
      const shardMass = Math.floor(mainPlayer.mass/2);
      mainPlayer.mass -= shardMass;
      // direction towards mouse
      let dx = mouse.x - mainPlayer.x, dy = mouse.y - mainPlayer.y;
      const dlen = Math.hypot(dx,dy) || 1;
      dx /= dlen; dy /= dlen;
      // initial shard speed should scale with its size: larger shards move slower
      // reuse botSpeedFactor so shard speed is consistent with bot movement scaling
      const baseSplitSpeed = 6; // tuned baseline
      const speed = clamp(baseSplitSpeed * botSpeedFactor(shardMass), 2, 12);
      // incorporate some of the player's current velocity so split feels natural
      const inheritVx = mainPlayer.vx * 0.5;
      const inheritVy = mainPlayer.vy * 0.5;
      const shard = {
        x: mainPlayer.x + dx * (massToRadius(mainPlayer.mass)+8),
        y: mainPlayer.y + dy * (massToRadius(mainPlayer.mass)+8),
        mass: shardMass,
        color: mainPlayer.color,
        vx: dx * speed + inheritVx,
        vy: dy * speed + inheritVy,
        age: 0,
        life: SHARD_LIFETIME,
        canMerge: false
      };
      shards.push(shard);
    }

    window.addEventListener('keydown', e => { if(e.code === 'Space'){ e.preventDefault(); trySplit(); } });

    function step(dt){
      // main player movement: moves toward mouse, slower when larger
      const r = massToRadius(mainPlayer.mass);
      const maxSpeed = Math.max(0.6, 4.6 - Math.log(mainPlayer.mass+1)*0.6);
      const ax = (mouse.x - mainPlayer.x) * 0.06;
      const ay = (mouse.y - mainPlayer.y) * 0.06;
      mainPlayer.vx += ax * 0.6; mainPlayer.vy += ay * 0.6;
      mainPlayer.vx *= 0.92; mainPlayer.vy *= 0.92;
      let speed = Math.hypot(mainPlayer.vx, mainPlayer.vy);
      if(speed > maxSpeed){ mainPlayer.vx = (mainPlayer.vx / speed) * maxSpeed; mainPlayer.vy = (mainPlayer.vy / speed) * maxSpeed; }
      mainPlayer.x += mainPlayer.vx; mainPlayer.y += mainPlayer.vy;
      mainPlayer.x = Math.max(5, Math.min(WIDTH()-5, mainPlayer.x));
      mainPlayer.y = Math.max(5, Math.min(HEIGHT()-5, mainPlayer.y));

  // shards movement & aging
      for(let i=shards.length-1;i>=0;i--){
        const s = shards[i];
        // age the shard (age in ms)
        s.age += dt*1000;
        if(s.age >= s.life) s.canMerge = true;

        if(!s.canMerge){
          // While shard is active after split, use the same movement model as the main player
          // so it follows the mouse at a similar, mass-scaled speed.
          const sMaxSpeed = Math.max(0.6, 4.6 - Math.log(s.mass+1)*0.6);
          const ax = (mouse.x - s.x) * 0.06;
          const ay = (mouse.y - s.y) * 0.06;
          s.vx += ax * 0.6; s.vy += ay * 0.6;
          s.vx *= 0.92; s.vy *= 0.92;
          let spd = Math.hypot(s.vx, s.vy);
          if(spd > sMaxSpeed){ s.vx = (s.vx / spd) * sMaxSpeed; s.vy = (s.vy / spd) * sMaxSpeed; }
          s.x += s.vx; s.y += s.vy;
        } else {
          // When shard can merge, actively move back toward the main player to rejoin
          const dx = mainPlayer.x - s.x, dy = mainPlayer.y - s.y;
          const dlen = Math.hypot(dx,dy) || 1;
          const dirx = dx / dlen, diry = dy / dlen;
          // approach speed increases slightly with shard size but is clamped
          const approachSpeed = clamp(1.2 + Math.log(s.mass+1) * 0.18, 0.8, 6);
          s.vx = dirx * approachSpeed;
          s.vy = diry * approachSpeed;
          s.x += s.vx; s.y += s.vy;
        }

  // wrap using radius-based margins to avoid ping-ponging on the edges
  const sr = massToRadius(s.mass);
  if(s.x < -sr) s.x = WIDTH() + sr;
  if(s.x > WIDTH() + sr) s.x = -sr;
  if(s.y < -sr) s.y = HEIGHT() + sr;
  if(s.y > HEIGHT() + sr) s.y = -sr;

        // try merge if allowed (close enough to main player)
        if(s.canMerge){
          const d = dist(s, mainPlayer);
          if(d < massToRadius(mainPlayer.mass) + massToRadius(s.mass) + 8){
            mainPlayer.mass += s.mass;
            shards.splice(i,1);
          }
        }
      }

      // player pieces eat food
      const playerPieces = [mainPlayer, ...shards];
      for(let i=foods.length-1;i>=0;i--){
        const f = foods[i];
        let eaten = false;
        for(const p of playerPieces){
          const d = dist(p, f);
          const rP = massToRadius(p.mass);
          const rF = massToRadius(f.mass);
          if(d < rP + 2){
            p.mass += f.mass; eaten = true; break;
          }
        }
        if(eaten){ foods.splice(i,1); foods.push(spawnFood()); }
      }


      // bots: eat nearby food first (cheaper check per bot)
      for(const b of bots){
        for(let fi = foods.length-1; fi >= 0; fi--){
          const f = foods[fi];
          const d = dist(b, f);
          const rB = massToRadius(b.mass);
          if(d < rB + 3){
            b.mass += f.mass;
            foods.splice(fi,1);
            foods.push(spawnFood());
            break;
          }
        }
      }

      // bots: smarter behavior (tuned to be less skittish and slower when big)
      for(const b of bots){
        // detect nearby threats (larger pieces) and targets
        let nearestTarget = null; let nearestTargetDist = 1e9;
        // consider main player and shards
        const pieces = [mainPlayer, ...shards];
        for(const p of pieces){
          const d = dist(b, p);
          // only consider as target if significantly smaller
          if(p.mass < b.mass * 0.9 && d < nearestTargetDist){ nearestTarget = p; nearestTargetDist = d; }
        }
        // also consider smaller bots as potential targets
        for(const other of bots){
          if(other === b) continue;
          const d = dist(b, other);
          if(other.mass < b.mass * 0.9 && d < nearestTargetDist){ nearestTarget = other; nearestTargetDist = d; }
        }
        // detect threats (only flee from much larger bots or shards) -- do NOT flee from the main player
        let nearestThreat = null; let threatDist = 1e9;
        // check other bots as threats
        for(const other of bots){
          if(other === b) continue;
          const d = dist(b, other);
          if(other.mass > b.mass * 1.6 && d < threatDist){ nearestThreat = other; threatDist = d; }
        }
        // check shards as potential threats (but skip mainPlayer intentionally)
        for(const s of shards){ const d = dist(b, s); if(s.mass > b.mass * 1.6 && d < threatDist){ nearestThreat = s; threatDist = d; } }

        const speedFactor = botSpeedFactor(b.mass);

        if(nearestThreat && threatDist < 220){
          // flee from threat (other bots/shards) using reduced speed for heavy bots
          const dx = b.x - nearestThreat.x, dy = b.y - nearestThreat.y;
          const ang = Math.atan2(dy, dx);
          b.dir = ang + rand(-0.3,0.3);
          const fleeSpeed = 1.0 * speedFactor;
          b.x += Math.cos(b.dir) * fleeSpeed;
          b.y += Math.sin(b.dir) * fleeSpeed;
        } else if(nearestTarget && nearestTargetDist < 600){
          // chase target moderately (bigger bots chase slower)
          const dx = nearestTarget.x - b.x, dy = nearestTarget.y - b.y;
          const ang = Math.atan2(dy, dx);
          b.dir = ang + rand(-0.12,0.12);
          const sp = (0.9 + (nearestTarget.mass < b.mass ? 0.25 : 0)) * speedFactor;
          b.x += Math.cos(b.dir) * sp;
          b.y += Math.sin(b.dir) * sp;
        } else {
          // wander (slower when heavier)
          b.dir += rand(-0.2,0.2);
          b.x += Math.cos(b.dir) * b.speed * speedFactor;
          b.y += Math.sin(b.dir) * b.speed * speedFactor;
        }

  // wrap using radius-based margins to avoid getting stuck on edges
  const br = massToRadius(b.mass);
  if(b.x < -br) b.x = WIDTH() + br;
  if(b.x > WIDTH() + br) b.x = -br;
  if(b.y < -br) b.y = HEIGHT() + br;
  if(b.y > HEIGHT() + br) b.y = -br;
      }

  // collisions & eating

      // player pieces eat bots
      for(let i=bots.length-1;i>=0;i--){
        const b = bots[i];
        for(let pidx = 0; pidx < playerPieces.length; pidx++){
          const p = playerPieces[pidx];
          const d = dist(p,b);
          const rPlayer = massToRadius(p.mass);
          const rBot = massToRadius(b.mass);
          if(rPlayer > rBot * 1.12 && d < rPlayer - rBot*0.35){
            // eat
            p.mass += b.mass * 0.85; // some loss
            bots[i] = spawnBot();
            break;
          }
        }
      }

      // bots eat bots
      for(let i=0;i<bots.length;i++){
        for(let j=i+1;j<bots.length;j++){
          const A = bots[i], B = bots[j];
          const d = dist(A,B);
          const rA = massToRadius(A.mass), rB = massToRadius(B.mass);
          if(rA > rB * 1.12 && d < rA - rB*0.35){
            A.mass += B.mass * 0.85;
            bots[j] = spawnBot();
          } else if(rB > rA * 1.12 && d < rB - rA*0.35){
            B.mass += A.mass * 0.85;
            bots[i] = spawnBot();
          }
        }
      }

      // bots can also eat player pieces
      for(const b of bots){
        for(let si = shards.length-1; si >= 0; si--){
          const s = shards[si];
          const d = dist(s, b);
          const rS = massToRadius(s.mass);
          const rB = massToRadius(b.mass);
          if(rB > rS * 1.12 && d < rB - rS*0.35){
            // shard eaten
            shards.splice(si,1);
            break;
          }
        }
        // check main player
        const dMain = dist(mainPlayer, b);
        const rMain = massToRadius(mainPlayer.mass);
        const rB = massToRadius(b.mass);
        if(rB > rMain * 1.12 && dMain < rB - rMain*0.35){
          // main player eaten -> game over
          running = false;
          showGameOver();
          return; // stop further processing
        }
      }

  // update HUD
  massEl.textContent = 'Mass: ' + Math.round(mainPlayer.mass) + (shards.length ? (' (+ ' + shards.length + ' shards)') : '');
  botsEl.textContent = 'Bots: ' + bots.length;
  if(foodEl) foodEl.textContent = 'Food: ' + foods.length;
  // update leaderboard (top 5 by mass)
  if(leadersEl){
    const list = [];
    list.push({name:'You', mass: mainPlayer.mass});
    for(let i=0;i<bots.length;i++) list.push({name: 'Bot', mass: bots[i].mass});
    list.sort((a,b) => b.mass - a.mass);
    const top = list.slice(0,5);
    leadersEl.innerHTML = top.map((e,idx) => `${idx+1}. ${e.name} — ${Math.round(e.mass)}`).join('<br>');
  }
    }

    function draw(){
      ctx.clearRect(0,0,WIDTH(),HEIGHT());
      // background grid subtle
      ctx.fillStyle = 'rgba(255,255,255,0.01)';
      for(let x=0;x<WIDTH();x+=120){ ctx.fillRect(x,0,0.6,HEIGHT()); }

      // Build a single list of drawable entities and sort by radius so smallest draw first
      const drawList = [];

      // foods (small, draw first)
      for(const f of foods){
        const fr = Math.max(2, Math.sqrt(f.mass/Math.PI)*1.6);
        drawList.push({type:'food', x:f.x, y:f.y, r:fr, color:f.color, mass:f.mass, obj:f});
      }

      // bots
      for(const b of bots){
        const r = massToRadius(b.mass);
        drawList.push({type:'bot', x:b.x, y:b.y, r:r, color:b.color, mass:b.mass, obj:b});
      }

      // shards
      for(const s of shards){
        const r = massToRadius(s.mass);
        drawList.push({type:'shard', x:s.x, y:s.y, r:r, color:s.color, mass:s.mass, obj:s});
      }

      // main player
      const pr = massToRadius(mainPlayer.mass);
      drawList.push({type:'player', x:mainPlayer.x, y:mainPlayer.y, r:pr, color:mainPlayer.color, mass:mainPlayer.mass, obj:mainPlayer});

      // sort ascending by radius (smallest first), so biggest drawn last -> appears on top
      drawList.sort((a,b) => a.r - b.r);

      // draw in order
      for(const e of drawList){
        if(e.type === 'food'){
          ctx.beginPath(); ctx.fillStyle = e.color; ctx.globalAlpha = 0.95; ctx.arc(e.x, e.y, e.r, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1;
        } else if(e.type === 'bot'){
          ctx.beginPath(); ctx.fillStyle = e.color; ctx.globalAlpha = 0.95; ctx.arc(e.x, e.y, e.r, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1;
          if(e.r > 12){ ctx.fillStyle = 'rgba(0,0,0,0.35)'; ctx.font = '10px sans-serif'; ctx.textAlign='center'; ctx.fillText(Math.round(e.mass), e.x, e.y+3); }
        } else if(e.type === 'shard'){
          ctx.beginPath(); ctx.fillStyle = e.color; ctx.globalAlpha = 0.98; ctx.arc(e.x, e.y, e.r, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1;
          if(e.r > 12){ ctx.fillStyle = 'rgba(0,0,0,0.35)'; ctx.font = '10px sans-serif'; ctx.textAlign='center'; ctx.fillText(Math.round(e.mass), e.x, e.y+3); }
        } else if(e.type === 'player'){
          // glow under the player (draw before the player circle) - since player is last if largest it'll appear on top
          ctx.beginPath(); ctx.fillStyle = '#19f0ff'; ctx.globalAlpha = 0.06; ctx.arc(e.x, e.y, e.r*1.8, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1;
          ctx.beginPath(); ctx.fillStyle = e.color; ctx.arc(e.x, e.y, e.r, 0, Math.PI*2); ctx.fill();
          ctx.fillStyle = '#000'; ctx.font = '12px sans-serif'; ctx.textAlign='center'; ctx.fillText(Math.round(e.mass), e.x, e.y+4);
        }
      }
    }

    let last = performance.now();
    function loop(now){
      const dt = Math.min(40, now - last);
      last = now;
      if(running){ step(dt/1000); draw(); requestAnimationFrame(loop); }
    }
    requestAnimationFrame(loop);

    // Game over UI
    const msg = document.getElementById('msg');
    const msgText = document.getElementById('msgText');
    const playAgain = document.getElementById('playAgain');

    function showGameOver(){ msgText.textContent = 'Vous avez été mangé !'; msg.classList.add('show'); }
    function resetGame(){
      mainPlayer.x = WIDTH()/2; mainPlayer.y = HEIGHT()/2; mainPlayer.mass = 120; mainPlayer.vx=0; mainPlayer.vy=0; shards.length = 0; running = true; msg.classList.remove('show');
      // reset bots
      for(let i=0;i<bots.length;i++) bots[i] = spawnBot();
      requestAnimationFrame(loop);
    }

    // buttons
    document.getElementById('back').addEventListener('click', ()=>{ location.href = '../index.html' });
    document.getElementById('reset').addEventListener('click', ()=>{ resetGame() });
    playAgain.addEventListener('click', ()=>{ resetGame() });

    // small safe guard: pause when page hidden
    document.addEventListener('visibilitychange', ()=>{ if(document.hidden) running=false; else if(!running && !msg.classList.contains('show')){ running=true; last = performance.now(); requestAnimationFrame(loop); } });

    // initial focus
    canvas.tabIndex = 0;
  </script>
</body>
</html>
