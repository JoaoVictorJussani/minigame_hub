<!DOCTYPE html>
<html lang="pt-br">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Tetris</title>
<style>
body {
  margin:0;
  font-family: Arial, sans-serif;
  display:flex;
  flex-direction:column;
  align-items:center;
  background: linear-gradient(to top, #222, #555);
  color:#fff;
}
h1 {
  margin-top: 20px;
  text-align:center;
}
canvas {
  background:#000;
  margin-top:20px;
  border:3px solid #555;
  border-radius:8px;
}
.controls {
  margin-top:15px;
}
button {
  padding:10px 15px;
  font-weight:bold;
  border:none;
  border-radius:8px;
  cursor:pointer;
  background-color:#2e8b57;
  color:white;
  font-size:16px;
  margin:5px;
}
button:hover { background-color:#246b46; }
</style>
</head>
<body>
<h1>ðŸ§± Tetris</h1>
<canvas id="tetris" width="300" height="600"></canvas>
<div class="controls">
  <button onclick="voltarHub()">â¬… Voltar ao Hub</button>
</div>
<div class="scoreboard" style="margin-top:10px;font-size:18px;">
  PontuaÃ§Ã£o: <span id="score">0</span> â€” Melhor: <span id="best">0</span>
</div>

<script>
const canvas = document.getElementById('tetris');
const ctx = canvas.getContext('2d');
const ROWS = 20;
const COLS = 10;
const BLOCK = 30;
canvas.width = COLS*BLOCK;
canvas.height = ROWS*BLOCK;

// cores das peÃ§as
const colors = [
  null,
  '#00f0f0', // I
  '#0000f0', // J
  '#f0a000', // L
  '#f0f000', // O
  '#00f000', // S
  '#a000f0', // T
  '#f00000'  // Z
];

// formas
const PIECES = [
  [],
  [[1,1,1,1]],          // I
  [[2,0,0],[2,2,2]],    // J
  [[0,0,3],[3,3,3]],    // L
  [[4,4],[4,4]],        // O
  [[0,5,5],[5,5,0]],    // S
  [[0,6,0],[6,6,6]],    // T
  [[7,7,0],[0,7,7]]     // Z
];

// arena
function createMatrix(w,h){
  const m = [];
  while(h--) m.push(new Array(w).fill(0));
  return m;
}

const arena = createMatrix(COLS,ROWS);

// jogador
const player = {
  pos: {x:0,y:0},
  matrix: null,
  score: 0
};

let bestScore = parseInt(localStorage.getItem('tetrisBest')||'0',10);
document.getElementById('best').textContent = bestScore;

function collide(arena,player){
  return player.matrix.some((row,y)=>{
    return row.some((value,x)=>{
      return value!==0 &&
             (arena[y+player.pos.y] && arena[y+player.pos.y][x+player.pos.x])!==0;
    });
  });
}

function merge(arena,player){
  player.matrix.forEach((row,y)=>{
    row.forEach((value,x)=>{
      if(value!==0) arena[y+player.pos.y][x+player.pos.x] = value;
    });
  });
}

function sweep(){
  let lines = 0;
  outer: for(let y=arena.length-1;y>=0;y--){
    if(arena[y].every(v=>v!==0)){
      arena.splice(y,1);
      arena.unshift(new Array(COLS).fill(0));
      lines++;
      y++;
    }
  }
  if(lines>0){
    player.score += lines*10;
    if(player.score>bestScore){
      bestScore = player.score;
      localStorage.setItem('tetrisBest',bestScore);
    }
    updateScore();
  }
}

function drawBlock(x,y,color){
  ctx.fillStyle = color;
  ctx.fillRect(x*BLOCK,y*BLOCK,BLOCK,BLOCK);
  ctx.strokeStyle = '#111';
  ctx.strokeRect(x*BLOCK,y*BLOCK,BLOCK,BLOCK);
}

function drawMatrix(matrix,offset){
  matrix.forEach((row,y)=>{
    row.forEach((value,x)=>{
      if(value!==0) drawBlock(x+offset.x,y+offset.y,colors[value]);
    });
  });
}

function draw(){
  ctx.fillStyle = '#000';
  ctx.fillRect(0,0,canvas.width,canvas.height);
  drawMatrix(arena,{x:0,y:0});
  drawMatrix(player.matrix,player.pos);
}

function updateScore(){
  document.getElementById('score').textContent = player.score;
  document.getElementById('best').textContent = bestScore;
}

function resetPlayer(){
  const r = Math.floor(Math.random()* (PIECES.length -1) ) +1;
  player.matrix = PIECES[r];
  player.pos.y = 0;
  player.pos.x = Math.floor((COLS - player.matrix[0].length)/2);
  if(collide(arena,player)){
    arena.forEach(row=>row.fill(0));
    player.score = 0;
    updateScore();
    alert("ðŸ’¥ Game Over!");
  }
}

function playerMove(dir){
  player.pos.x += dir;
  if(collide(arena,player)) player.pos.x -= dir;
}

function playerDrop(){
  player.pos.y++;
  if(collide(arena,player)){
    player.pos.y--;
    merge(arena,player);
    sweep();
    resetPlayer();
  }
  dropCounter=0;
}

// rotaÃ§Ã£o que funciona pra todas as peÃ§as
function rotate(matrix, dir){
  const N = matrix.length;
  const M = matrix[0].length;
  const result = [];
  for(let y=0;y<M;y++){
    result[y] = [];
    for(let x=0;x<N;x++){
      if(dir>0) result[y][x] = matrix[N-1-x][y];
      else result[y][x] = matrix[x][M-1-y];
    }
  }
  matrix.length = 0;
  result.forEach(r => matrix.push(r));
}

function playerRotate(dir){
  const pos = player.pos.x;
  rotate(player.matrix, dir);
  let offset = 1;
  while(collide(arena,player)){
    player.pos.x += offset;
    offset = -(offset + (offset>0?1:-1));
    if(offset > player.matrix[0].length){
      rotate(player.matrix,-dir);
      player.pos.x = pos;
      return;
    }
  }
}

let dropCounter = 0;
let dropInterval = 1000;
let lastTime = 0;

function update(time=0){
  const deltaTime = time - lastTime;
  lastTime = time;
  dropCounter += deltaTime;
  if(dropCounter>dropInterval) playerDrop();
  draw();
  requestAnimationFrame(update);
}

window.addEventListener('keydown', e=>{
  if(e.key==='ArrowLeft') playerMove(-1);
  else if(e.key==='ArrowRight') playerMove(1);
  else if(e.key==='ArrowDown') playerDrop();
  else if(e.key==='ArrowUp') playerRotate(1);
  else if(e.code==='Space'){ e.preventDefault(); playerRotate(1); }
});

function voltarHub(){ window.location.href='../index.html'; }

resetPlayer();
update();
</script>
</body>
</html>
